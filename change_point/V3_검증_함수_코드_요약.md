# V3 검증 함수 코드 요약

## 1. 주요 함수

### 1.1. `validate_first_anchor_extended_window_v3_cp()`
**위치**: `change_point_hypothesis_module.py` (2282-2518줄)

**기능**: 단일 grid_string에 대한 V3 검증 수행

**핵심 로직**:
- 앵커 기반 순차 검증 시스템
- **첫 번째 앵커부터 검증 시작** (`current_pos = 0`, `anchor_idx = 0`)
- [REQ-101] current_pos 이후의 가장 빠른 앵커 선택 (앵커 인덱스 추적으로 최적화)
- [REQ-102] 윈도우 크기 9, 10, 11, 12, 13, 14 순차 검증
- [RULE-1] 적중 시 즉시 종료 (matched_pos + 1로 current_pos 업데이트)
- [RULE-2] 3회 연속 불일치 시 앵커 실패 (mismatched_pos + 1로 current_pos 업데이트)
- 스킵 처리: 예측값이 없으면 스킵 (연속 실패 카운트에 포함하지 않음)

**예측값 조회**:
```python
# 시뮬레이션 전용 테이블에서 조회
q = """
    SELECT predicted_value, confidence, b_ratio, p_ratio
    FROM simulation_predictions_change_point
    WHERE window_size = ? AND prefix = ? AND method = ? AND threshold = ?
    LIMIT 1
"""
```

---

### 1.2. `generate_simulation_predictions_table()`
**위치**: `change_point_hypothesis_module.py` (2699-2755줄)

**기능**: 시뮬레이션 전용 예측 테이블 생성 및 예측값 저장

**사용 방법**:
```python
result = generate_simulation_predictions_table(
    cutoff_grid_string_id=cutoff_id,
    window_sizes=(9, 10, 11, 12, 13, 14),
    method="빈도 기반",
    threshold=0,
    min_sample_count=15,
)
```

**반환값**:
```python
{
    "total_saved": int,      # 총 저장된 레코드 수
    "new_records": int,      # 새로 생성된 레코드 수
    "updated_records": int,  # 업데이트된 레코드 수
    "unique_prefixes": int,  # 고유 prefix 수
}
```

---

### 1.3. `batch_validate_first_anchor_extended_window_v3_cp()`
**위치**: `change_point_hypothesis_module.py` (2757-2839줄)

**기능**: 배치 검증 (cutoff 이후 모든 grid_string 검증)

**주의사항**:
- **예측값 테이블 생성이 분리됨**
- 검증 전에 `generate_simulation_predictions_table()` 함수를 먼저 실행해야 함
- `auto_generate_predictions` 파라미터 제거됨

**사용 방법**:
```python
# 1단계: 예측값 테이블 생성
generate_simulation_predictions_table(
    cutoff_grid_string_id=cutoff_id,
    window_sizes=(9, 10, 11, 12, 13, 14),
    method="빈도 기반",
    threshold=0,
)

# 2단계: 시뮬레이션 실행
results = batch_validate_first_anchor_extended_window_v3_cp(
    cutoff_grid_string_id=cutoff_id,
    window_sizes=(9, 10, 11, 12, 13, 14),
    method="빈도 기반",
    threshold=0,
    stop_on_match=False,
)
```

---

## 2. 앱에서의 사용 방법

### 2.1. 예측값 테이블 생성
1. V3 가설 선택
2. 윈도우 크기 선택 (9-14)
3. Cutoff ID 선택
4. 임계값 설정
5. **"예측값 테이블 생성" 버튼 클릭** (시간 소요 가능)

### 2.2. 시뮬레이션 실행
1. 예측값 테이블 생성 완료 후
2. **"시뮬레이션 실행" 버튼 클릭**
3. 결과 확인

---

## 3. 주요 변경사항

### 3.1. 예측값 테이블 생성과 시뮬레이션 실행 분리
- **이전**: `batch_validate_first_anchor_extended_window_v3_cp()` 내부에서 자동 생성
- **현재**: `generate_simulation_predictions_table()` 함수로 별도 실행

### 3.2. 성능 개선
- 예측값 생성 시간과 시뮬레이션 실행 시간 분리
- 예측값 테이블 재사용 가능 (동일한 cutoff/설정으로 반복 실행 시)

### 3.3. 사용자 경험 개선
- 예측값 생성 진행 상황 확인 가능
- 예측값 생성 실패 시 명확한 에러 메시지
- 시뮬레이션 실행 전 예측값 테이블 존재 여부 확인

---

## 4. V3 검증 로직 요약

### 4.1. 검증 시작
- **첫 번째 앵커부터 검증 시작**: `current_pos = 0`, `anchor_idx = 0`
- 첫 번째 앵커(`anchors[0]`)에서 윈도우 크기별 검증 시작

### 4.2. 앵커 선택 (최적화됨)
```python
# 앵커 인덱스를 추적하여 효율적으로 다음 앵커 찾기
anchor_idx = 0  # 첫 번째 앵커부터 시작

while anchor_idx < len(anchors) and anchors[anchor_idx] < current_pos:
    anchor_idx += 1  # current_pos 이후의 앵커 찾기

next_anchor = anchors[anchor_idx]  # 다음 앵커 선택
```

**최적화 포인트**:
- 매번 처음부터 순회하지 않고 인덱스를 추적하여 O(1) 접근
- 이전 방식 대비 성능 개선

### 4.3. 윈도우 크기별 순차 검증
```python
for window_size in window_sizes:  # 9, 10, 11, 12, 13, 14
    pos = next_anchor + window_size - 1
    # 예측값 조회 및 검증
    # [RULE-1] 적중 시 즉시 종료
    # [RULE-2] 3회 연속 불일치 시 앵커 실패
```

### 4.4. 포지션 업데이트
- **적중 시**: `current_pos = matched_pos + 1`, `anchor_idx += 1` (다음 앵커로)
- **3회 연속 불일치 시**: `current_pos = mismatched_pos + 1`, `anchor_idx += 1` (다음 앵커로)
- **윈도우 루프 종료 시**: 처리한 포지션이 있으면 그 다음으로, 없으면 앵커의 최대 포지션 다음으로 이동

### 4.5. 무한 루프 방지
- 윈도우 크기 루프가 끝났을 때 `current_pos`가 업데이트되지 않으면 자동으로 업데이트
- `anchor_processed_any` 플래그로 실제 처리 여부 추적
- 모든 경우에 `current_pos`가 업데이트되어 다음 앵커로 진행 보장

---

## 5. V3 검증 규칙 상세 요약

### 5.1. 검증 시작 규칙
- **[REQ-101]** 첫 번째 앵커부터 검증 시작
- 이후 `current_pos` 이후의 가장 빠른 앵커를 검증 대상으로 선정
- **[REQ-102]** 검증에 사용하는 윈도우 크기는 순차적으로 9, 10, 11, 12, 13, 14

### 5.2. 적중 시 즉시 종료 규칙 [RULE-1]
- **조건**: 윈도우 $W_n$에서 예측값이 실제 결과와 **일치(Match)**
- **동작**: 
  - 즉시 해당 앵커에 대한 모든 검증을 성공으로 간주하고 종료
  - 나머지 윈도우 크기는 검증하지 않음
- **전이**: `current_pos = matched_pos + 1`, 다음 앵커 탐색
- **예시**: 윈도우 9에서 바로 맞으면 10, 11...은 검사하지 않고 종료

### 5.3. 불일치 시 확장 검증 규칙 [RULE-2]
- **조건**: 예측값이 **불일치(Mismatch)**
- **동작**: 
  - 다음 윈도우 $W_{n+1}$로 넘어가 검증을 계속
  - 3회 연속 불일치 발생 시 해당 앵커 검증을 실패로 간주하고 종료
- **전이**: `current_pos = mismatched_pos + 1` (3번째 불일치 포지션의 다음 인덱스), 다음 앵커 탐색
- **예시**: 
  - 윈도우 9 [틀림] → 윈도우 10 [틀림] → 윈도우 11 [틀림] → 실패 종료

### 5.4. 스킵 처리 규칙
- **조건**: 예측 테이블에 값이 없는 경우
- **동작**: 
  - 스킵 처리 (연속 실패 카운트에 포함하지 않음)
  - 다음 윈도우 크기로 계속 진행
- **전이**: 스킵된 예측은 `anchor_consecutive_failures`에 카운트되지 않음

### 5.5. 검증 프로세스 시나리오

#### Case 1: 즉시 성공
```
첫 번째 앵커 → 윈도우 9 예측 [적중] → 종료 (다음 앵커 탐색)
```

#### Case 2: 지연 성공
```
첫 번째 앵커 → 윈도우 9 [틀림] → 윈도우 10 [틀림] → 윈도우 11 [적중] → 종료 (다음 앵커 탐색)
```

#### Case 3: 최종 실패
```
첫 번째 앵커 → 윈도우 9 [틀림] → 윈도우 10 [틀림] → 윈도우 11 [틀림] → 실패 종료 (3회 연속 불일치 확정, 다음 앵커 탐색)
```

#### Case 4: 스킵 포함
```
첫 번째 앵커 → 윈도우 9 [스킵] → 윈도우 10 [틀림] → 윈도우 11 [틀림] → 윈도우 12 [틀림] → 실패 종료 (스킵은 카운트되지 않음)
```

---

## 6. 테이블 구조

### 6.1. `simulation_predictions_change_point`
- 시뮬레이션 전용 예측 테이블
- 기존 `stored_predictions_change_point` 테이블과 동일한 스키마
- 시뮬레이션 실행 시마다 재생성 (DROP TABLE IF EXISTS)

### 6.2. 인덱스
- `idx_sim_cp_sp_window_prefix`: (window_size, prefix)
- `idx_sim_cp_sp_method_threshold`: (method, threshold)

---

## 7. 주의사항

1. **예측값 테이블 생성 시간**: 데이터 양에 따라 수십 초~수분 소요 가능
2. **시뮬레이션 실행 전 확인**: 예측값 테이블이 생성되었는지 확인 필요
3. **테이블 재생성**: 시뮬레이션마다 테이블이 삭제되고 재생성됨
4. **기존 DB 보호**: `stored_predictions_change_point` 테이블은 수정하지 않음
