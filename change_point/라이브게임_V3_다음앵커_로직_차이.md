# 라이브 게임(V4/V5) vs V3: "다음 앵커" 선택 로직 차이

## 개요

앵커 검증이 한 번 종료된 뒤 **다음에 검증할 앵커**를 정할 때,  
**V3(hypothesis_module)** 와 **라이브 게임(V4/V5)** 의 기준이 다릅니다.

- **V3**: 종료 시점의 **position(current_pos)** 기준으로, **그 위치보다 뒤에 있는** 첫 앵커를 선택한다.
- **라이브 게임(V4/V5)**: 종료 시점의 **position(current_pos)** 에 대해 **예측이 가능한** 앵커 중 **가장 앞선(낮은)** 앵커를 선택한다.

즉, “다음 앵커”의 정의가 **위치 기준**인지 **예측 가능 여부 기준**인지에서 차이가 난다.

---

## 1. V3 로직 (change_point_hypothesis_module)

**함수**: `validate_first_anchor_extended_window_v3_cp`  
**위치**: `change_point_hypothesis_module.py` 2380~2388행 근처

```python
# [REQ-101] current_pos 이후의 가장 빠른 앵커 찾기
# 이미 정렬된 anchors 리스트를 활용하여 인덱스로 접근
while anchor_idx < len(anchors) and anchors[anchor_idx] < current_pos:
    anchor_idx += 1
```

**의미**

- “**current_pos 이후의** 가장 빠른 앵커”를 고른다.
- 비교 대상은 **앵커의 위치** `anchors[anchor_idx]` 이다.
- `anchors[anchor_idx] < current_pos` 인 동안만 skip →  
  **조건**: `anchors[anchor_idx] >= current_pos` 인 첫 앵커를 선택한다.

**정리**:  
“앵커 검증이 종료된 시점의 **position(current_pos)** 부터 새로 앵커를 찾는데,  
**앵커 위치가 current_pos 이상인** 첫 앵커를 다음 앵커로 쓴다.”

---

## 2. 라이브 게임 로직 (V4/V5)

**함수**: `validate_grid_string_v3_cp`  
**위치**: `change_point_live_game_app_v4.py` / `change_point_live_game_app_v5.py` 99~105행 근처

```python
max_ws = max(window_sizes)
while current_pos < len(grid_string) and anchor_idx < len(anchors):
    # 해당 앵커가 커버할 수 있는 최대 position(anchor+max_ws-1)을 이미 지났을 때만 skip
    while anchor_idx < len(anchors) and anchors[anchor_idx] + max_ws - 1 < current_pos:
        anchor_idx += 1
    # ...
```

**의미**

- “해당 앵커가 **커버할 수 있는 최대 position**” = `anchor + max_ws - 1` (max_ws=14 이면 anchor+13).
- `anchor + max_ws - 1 < current_pos` 인 동안만 skip →  
  **조건**: `anchor + max_ws - 1 >= current_pos` 인 첫 앵커를 선택한다.
- 즉, **current_pos(또는 그 이후)** 를 어떤 윈도우로라도 **예측할 수 있는** 앵커 중,  
  **가장 앞선(낮은)** 앵커를 고른다.

**정리**:  
“종료 시점의 **position(current_pos)** 에 대해 **예측이 가능한** 앵커들 중  
**가장 낮은(앞선) 앵커**를 다음 앵커로 쓴다.”

---

## 3. 동작 차이 예시

**상황**:  
앵커 0이 position 10에서 종료 → `current_pos = 11`  
`anchors = [0, 3, 5, 6, 7, 8]`, `max_ws = 14`

| 구분 | 조건 | 다음 앵커 |
|------|------|-----------|
| **V3** | `anchors[anchor_idx] >= 11` 인 첫 앵커 | **없음** (0,3,5,6,7,8 모두 &lt; 11) → 앵커를 다 넘기고 루프 종료 |
| **V4/V5** | `anchors[anchor_idx] + 13 >= 11` 인 첫 앵커 | **앵커 3** (3+13≥11, 그리고 앵커 0은 이미 처리된 뒤라 `anchor_idx=1` → 앵커 3 사용). position 11은 앵커 3 + 윈도우 9 로 예측 가능 |

**결과**

- **V3**: `current_pos=11` 이후로는 “앵커 위치 ≥ 11”인 앵커가 없어, 여기서 더 검증할 앵커가 없다고 본다.
- **V4/V5**: position 11은 앵커 3 + 윈도우 9로 예측 가능하므로, “다음 앵커 = 앵커 3”으로 두고 그 앵커에 대한 검증·다음 예측을 이어간다.

---

## 4. 표로 정리

| 항목 | V3 (hypothesis_module) | 라이브 게임 (V4/V5) |
|------|------------------------|---------------------|
| **문구** | current_pos **이후의** 가장 빠른 앵커 | current_pos를 **예측 가능한** 가장 낮은 앵커 |
| **기준** | 앵커 **위치** ≥ current_pos | 앵커가 **커버 가능한 최대 position** ≥ current_pos |
| **skip 조건** | `anchors[anchor_idx] < current_pos` | `anchors[anchor_idx] + max_ws - 1 < current_pos` |
| **선택 조건** | `anchors[anchor_idx] >= current_pos` | `anchors[anchor_idx] + (max_ws - 1) >= current_pos` |

---

## 5. 요약

- **V3**:  
  “앵커 검증이 끝난 **그 시점의 position(current_pos)** 부터  
  **앵커 위치가 그 position 이상인** 첫 앵커를 다음 앵커로 선택”  
  → **위치 기준**이다.

- **라이브 게임(V4/V5)**:  
  “같은 **current_pos**에 대해  
  **그 position을 (어떤 윈도우로라도) 예측할 수 있는** 앵커들 중  
  **가장 앞선 앵커**를 다음 앵커로 선택”  
  → **예측 가능 여부 + 가장 낮은 앵커** 기준이다.

그래서 `current_pos`가 앵커 위치들보다 클 때(예: 11, 앵커는 0,3,5,…)  
V3는 “다음 앵커 없음”으로 끝나는 반면,  
라이브 게임은 “position 11을 앵커 3 + 윈도우 9로 예측 가능하니, 다음 앵커 = 3”으로 이어갈 수 있다.

---

## 6. 참고 코드 위치

| 구분 | 파일 | 함수 | 행(대략) |
|------|------|------|----------|
| V3 | `change_point_hypothesis_module.py` | `validate_first_anchor_extended_window_v3_cp` | 2380~2388 |
| 라이브 게임 | `change_point_live_game_app_v4.py` / `change_point_live_game_app_v5.py` | `validate_grid_string_v3_cp` | 99~105 |
| **가설(모듈)** | `change_point_hypothesis_module.py` | `validate_first_anchor_extended_window_v3_live_next_anchor_cp` | 2558~ |

(코드 수정 없이, 위 위치 기준으로 로직만 문서화함.)

---

## 7. hypothesis_module 내 신규 가설

라이브 게임의 “다음 앵커 선택 방식”을 **기존 코드 수정 없이** 새 가설로 추가한 함수가 있다.

- **단일 검증**: `validate_first_anchor_extended_window_v3_live_next_anchor_cp(grid_string_id, cutoff_grid_string_id, ...)`
- **배치 검증**: `batch_validate_first_anchor_extended_window_v3_live_next_anchor_cp(cutoff_grid_string_id, ...)`

시그니처·반환 형태는 V3와 동일하다. 다음 앵커 선택만 [REQ-101-LIVE] 및 `exit_for_pos_beyond` 로직을 사용한다.
