# Change-point 기반 검증 로직 요약

## 개요
Change-point Detection 기반으로 N-gram 예측을 수행하고, 임계값 스킵 전략과 앵커 우선순위를 적용하여 검증하는 로직입니다.

---

## 1. 전체 검증 흐름

### 1.1 초기 검증 (`validate_initial_grid_string`)
게임 시작 시점의 `grid_string`에 대해 모든 position에 대해 예측을 수행하고 검증합니다.

```
입력: grid_string, anchors, window_sizes, method, window_thresholds
출력: history 리스트 (각 position에 대한 예측 및 검증 결과)

1. max_ws = max(window_sizes) 계산
2. position = max_ws부터 len(grid_string) - 1까지 반복:
   - predict_for_position() 호출하여 예측 수행
   - 실제값 = grid_string[position]
   - 예측값과 실제값 비교하여 is_correct 계산
   - history에 결과 저장
3. history 반환
```

**특징:**
- 최소 윈도우 크기 이상인 position만 검증 가능
- 게임 시작 전 전체 스트링에 대한 이전 히스토리 생성

---

## 2. Position별 예측 로직 (`predict_for_position`)

### 2.1 가능한 앵커 찾기
특정 `position`에서 예측 가능한 모든 앵커를 찾습니다.

```
조건:
- anchor <= position (앵커가 position보다 앞에 있어야 함)
- anchor + window_size - 1 == position (해당 position에 도달 가능)
- position >= window_size - 1 (prefix 조건 충족)
```

### 2.2 앵커 우선순위 정렬
```
우선순위 규칙:
1. 작은 앵커 우선 (이전 앵커 우선순위)
2. 같은 앵커 내에서는 큰 윈도우 우선

정렬: possible_anchors = sorted(possible_anchors)  # 작은 순서대로
```

### 2.3 앵커별 예측 시도
각 앵커를 작은 순서대로 시도하며, 첫 번째 성공한 예측을 사용합니다.

```
for anchor in possible_anchors:  # 작은 앵커부터
    pred_res = hypothesis.predict(
        grid_string, position, 
        window_sizes=window_sizes,
        method=method,
        anchor=anchor,
        window_thresholds=window_thresholds
    )
    
    if pred_res.get("predicted") is not None and not pred_res.get("skipped"):
        selected_result = pred_res
        selected_anchor = anchor
        break  # 성공했으므로 더 이상 시도하지 않음
```

**핵심:**
- 이전 앵커(작은 인덱스)에서 성공하면 다음 앵커는 시도하지 않음
- 실패한 앵커는 디버깅 정보에 기록

---

## 3. 앵커별 예측 로직 (`ThresholdSkipAnchorPriorityHypothesis.predict`)

### 3.1 윈도우 크기별 예측 시도
특정 앵커에서 해당 position에 도달 가능한 모든 윈도우 크기를 시도합니다.

```
for window_size in window_sizes:
    expected_pos = anchor + window_size - 1
    if expected_pos != position:
        continue  # 해당 position에 도달 불가
    
    # Prefix 계산
    prefix_len = window_size - 1
    if position < prefix_len:
        # prefix 길이 부족 → 스킵
        continue
    if position > len(grid_string):
        # position 범위 초과 → 스킵
        continue
    
    prefix = grid_string[position - prefix_len : position]
    
    # DB에서 예측값 조회
    예측값, 신뢰도 = DB_조회(window_size, prefix, method)
    
    if 예측값 없음:
        스킵 (reason: "DB에 예측값 없음")
        continue
    
    # 임계값 확인
    ws_threshold = window_thresholds.get(window_size, threshold)
    if confidence < ws_threshold:
        스킵 (reason: "임계값 미만")
        continue
    
    # 성공: 예측값 반환
    all_predictions.append({window_size, prefix, predicted, confidence})
```

### 3.2 최고 신뢰도 선택
같은 앵커에서 여러 윈도우 크기가 성공한 경우, **가장 큰 윈도우 크기**를 선택합니다.

```
if all_predictions:
    # 가장 큰 윈도우 크기 선택
    selected = max(all_predictions, key=lambda x: x["window_size"])
    return {
        "predicted": selected["predicted"],
        "confidence": selected["confidence"],
        "window_size": selected["window_size"],
        "prefix": selected["prefix"],
        "skipped": False
    }
```

**핵심:**
- 같은 앵커 내에서는 큰 윈도우 우선
- 임계값 미만이면 스킵
- 모든 시도는 `all_attempts_debug`에 기록

---

## 4. 우선순위 요약

### 4.1 앵커 우선순위
```
1순위: 작은 앵커 (이전 앵커)
2순위: 큰 앵커 (나중 앵커)
```

**예시:**
- Position 12에서 앵커 2와 앵커 5가 모두 가능한 경우
- 앵커 2를 먼저 시도
- 앵커 2에서 성공하면 앵커 5는 시도하지 않음

### 4.2 윈도우 크기 우선순위 (같은 앵커 내)
```
1순위: 큰 윈도우 크기
2순위: 작은 윈도우 크기
```

**예시:**
- 앵커 2에서 윈도우 12, 11, 10이 모두 성공한 경우
- 윈도우 12를 선택

---

## 5. 디버깅 정보 구조

### 5.1 `all_attempts` 구조
각 position에서 시도한 모든 앵커-윈도우 조합을 기록합니다.

```
all_attempts = [
    {
        "anchor": 앵커 위치,
        "window_size": 윈도우 크기,
        "predicted": 예측값 (없으면 None),
        "confidence": 신뢰도,
        "skipped": 스킵 여부,
        "rejection_reason": 탈락 사유
    },
    ...
]
```

### 5.2 탈락 사유 (`rejection_reason`)
- `"선택됨"`: 최종적으로 선택된 조합
- `"이전 앵커에서 성공"`: 이전 앵커에서 성공하여 시도하지 않음
- `"DB에 예측값 없음"`: DB에 해당 prefix의 예측값이 없음
- `"임계값 미만 (XX% < YY%)"`: 신뢰도가 윈도우별 임계값보다 낮음
- `"prefix 길이 부족"`: position이 prefix 길이보다 작음
- `"position 범위 초과"`: position이 grid_string 길이를 초과

### 5.3 정렬 규칙
디버깅 정보는 우선순위대로 정렬되어 표시됩니다:
```
all_attempts.sort(key=lambda x: (x.get('anchor', 0), -x.get('window_size', 0)))
```
- 작은 앵커 우선
- 같은 앵커 내에서는 큰 윈도우 우선

---

## 6. 검증 결과 구조

### 6.1 History 항목
```
{
    'step': 스텝 번호 (1부터 시작),
    'position': 예측한 position,
    'anchor': 선택된 앵커,
    'window_size': 선택된 윈도우 크기,
    'prefix': 사용된 prefix,
    'predicted': 예측값,
    'actual': 실제값,
    'is_correct': 정답 여부 (True/False/None),
    'confidence': 신뢰도,
    'skipped': 스킵 여부,
    'validated': True,
    'interval': 0,
    'debug_info': 디버깅 정보
}
```

---

## 7. 주요 특징

### 7.1 임계값 스킵 전략
- 윈도우 크기별로 개별 임계값 설정 가능
- 신뢰도가 임계값 미만이면 스킵
- 스킵된 예측은 검증 결과에 포함되지 않음 (`is_correct = None`)

### 7.2 앵커 중첩 처리
- 여러 앵커가 같은 position을 예측할 수 있는 경우
- 이전 앵커(작은 인덱스)를 우선 시도
- 이전 앵커에서 성공하면 다음 앵커는 시도하지 않음

### 7.3 전체 스트링 검증
- 게임 시작 시점의 전체 `grid_string`에 대해 모든 position 검증
- 실제값 입력 전에도 이전 히스토리 확인 가능
- 실제값 입력 후에는 새로운 position에 대해 예측 수행

---

## 8. 예시 시나리오

### 시나리오: `bppbbbppppbb` (길이 12), Position 12 예측

**앵커 감지:** `[1, 3, 5]` (Change-point Detection 결과)

**가능한 앵커-윈도우 조합:**
- 앵커 1 + 윈도우 12: 1 + 12 - 1 = 12 ✅
- 앵커 3 + 윈도우 10: 3 + 10 - 1 = 12 ✅
- 앵커 5 + 윈도우 8: 5 + 8 - 1 = 12 ✅

**우선순위 시도 순서:**
1. **앵커 1 + 윈도우 12** 시도
   - Prefix: `grid_string[0:12]` = `bppbbbppppbb`
   - DB 조회 → 예측값 있음, 신뢰도 60%
   - 임계값 50% → 통과 ✅
   - **선택됨!** (더 이상 시도하지 않음)

2. 앵커 3, 앵커 5는 시도하지 않음 (이전 앵커에서 성공)

**디버깅 정보:**
```
Position: 12
- 앵커 1, 윈도우 12: 선택됨 (신뢰도 60%)
- 앵커 3, 윈도우 10: 이전 앵커에서 성공
- 앵커 5, 윈도우 8: 이전 앵커에서 성공
```

---

## 9. 핵심 로직 요약

```
1. Change-point Detection으로 앵커 위치 감지
2. 예측할 position 결정 (len(grid_string))
3. 가능한 앵커 찾기 (anchor <= position, anchor + window_size - 1 == position)
4. 앵커를 작은 순서대로 정렬 (이전 앵커 우선)
5. 각 앵커를 순서대로 시도:
   a. 해당 앵커에서 가능한 모든 윈도우 크기 시도
   b. Prefix 계산 및 DB 조회
   c. 임계값 확인 (윈도우별 임계값)
   d. 성공하면 가장 큰 윈도우 선택
   e. 성공한 예측이 있으면 즉시 반환 (다음 앵커 시도 안 함)
6. 모든 시도는 디버깅 정보에 기록
7. 검증 결과 저장 (예측값, 실제값, 정답 여부)
```

---

## 10. 검증 완료 조건

- **성공:** 예측값이 있고 임계값 이상이며 실제값과 일치
- **실패:** 예측값이 있고 임계값 이상이지만 실제값과 불일치
- **스킵:** 예측값이 없거나 임계값 미만
- **불가능:** 가능한 앵커가 없거나 prefix 조건 미충족

---

---

## 11. 데이터베이스 정보

### 11.1 데이터베이스 파일
- **파일 경로:** `change_point/change_point_ngram.db`
- **연결 함수:** `get_change_point_db_connection()` (from `svg_parser_module`)

### 11.2 예측값 테이블: `stored_predictions_change_point`

#### 테이블 구조
```sql
CREATE TABLE stored_predictions_change_point (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    window_size INTEGER NOT NULL,
    prefix TEXT NOT NULL,
    predicted_value TEXT,
    confidence REAL,
    b_ratio REAL,
    p_ratio REAL,
    method TEXT NOT NULL,
    threshold REAL NOT NULL,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    UNIQUE(window_size, prefix, method, threshold)
)
```

#### 인덱스
- `idx_cp_sp_window_prefix`: `(window_size, prefix)`
- `idx_cp_sp_method_threshold`: `(method, threshold)`

### 11.3 예측값 조회 쿼리

```sql
SELECT predicted_value, confidence, b_ratio, p_ratio
FROM stored_predictions_change_point
WHERE window_size = ? 
  AND prefix = ? 
  AND method = ? 
  AND threshold = ?
LIMIT 1
```

#### 쿼리 파라미터
- `window_size`: 윈도우 크기 (8, 9, 10, 11, 12 등)
- `prefix`: prefix 문자열 (예: `"bppbbbppppbb"`)
- `method`: 예측 방법 (예: `"빈도 기반"`)
- `threshold`: DB에 저장된 예측값의 threshold (일반적으로 `0`)

**참고:** 
- 실제 임계값 비교는 `confidence`와 `window_thresholds`로 수행됩니다.
- DB의 `threshold` 컬럼은 예측값 생성 시 사용된 임계값을 의미하며, 라이브 게임에서는 일반적으로 `0`으로 조회합니다.

#### 반환 컬럼
- `predicted_value`: 예측값 (`'b'` 또는 `'p'`)
- `confidence`: 신뢰도 (0.0 ~ 100.0)
- `b_ratio`: b 비율 (0.0 ~ 100.0)
- `p_ratio`: p 비율 (0.0 ~ 100.0)

### 11.4 예측값 생성
예측값은 `change_point_prediction_module.py`의 `save_or_update_predictions_for_change_point_data()` 함수를 통해 생성됩니다.

**생성 조건:**
- `ngram_chunks_change_point` 테이블의 데이터를 기반으로 통계 계산
- 최소 표본 수 필터 적용 가능 (설정에 따라)
- Change-point Detection 기반으로 생성된 N-gram 데이터 사용

---

*최종 업데이트: 2026-01-26*
