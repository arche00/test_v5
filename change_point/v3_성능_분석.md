# V3 검증 함수 성능 분석

## 성능 병목 원인 분석

### 1. 예측값 자동 생성 (가장 큰 원인)

**문제점:**
- `batch_validate_first_anchor_extended_window_v3_cp()` 함수에서 `auto_generate_predictions=True`일 때 매번 `save_or_update_predictions_for_change_point_data()` 호출
- 이 함수는 매우 무거운 작업을 수행:
  - `ngram_chunks_change_point` 테이블에서 학습 데이터 로드
  - 각 윈도우 크기(9, 10, 11, 12, 13, 14)별로 모델 구축
  - 모든 prefix에 대해 예측값 계산 및 DB 저장
  - 수천~수만 개의 레코드를 처리

**영향:**
- 배치 검증 시작 시마다 예측값 생성에 수십 초~수분 소요 가능
- 동일한 cutoff에 대해 반복 실행 시 불필요한 재생성

**해결 방안:**
1. 예측값이 이미 존재하는지 확인 후 생성 여부 결정
2. 예측값 생성 결과를 캐싱
3. `auto_generate_predictions=False`로 설정하여 수동 생성

---

### 2. 앵커 탐색 비효율

**문제점:**
```python
# 현재 구현 (2376-2381줄)
while current_pos < len(grid_string):
    next_anchor = None
    for anchor in anchors:  # 매번 처음부터 순회
        if anchor >= current_pos:
            next_anchor = anchor
            break
```

- 매 while 루프마다 anchors 리스트를 처음부터 순회
- anchors가 정렬되어 있으므로 이진 탐색이나 인덱스 추적으로 최적화 가능

**영향:**
- 앵커가 많을수록 탐색 시간 증가
- O(n) 시간 복잡도

**해결 방안:**
- 이진 탐색 사용 (`bisect` 모듈)
- 또는 앵커 인덱스를 추적하여 다음 앵커를 바로 찾기

---

### 3. DB 쿼리 최적화

**문제점:**
- 각 윈도우 크기별로 개별 쿼리 실행
- 각 grid_string 검증마다 DB 연결 생성/해제

**현재 쿼리:**
```python
q = """
    SELECT predicted_value, confidence, b_ratio, p_ratio
    FROM stored_predictions_change_point
    WHERE window_size = ? AND prefix = ? AND method = ? AND threshold = ?
    LIMIT 1
"""
```

**영향:**
- 윈도우 크기 6개 × 앵커 수 × grid_string 수만큼 쿼리 실행
- DB 연결 오버헤드

**해결 방안:**
- 배치 쿼리로 여러 윈도우 크기를 한 번에 조회
- DB 연결 재사용 (배치 검증에서 하나의 연결 사용)

---

### 4. 불필요한 포지션 체크

**문제점:**
```python
# 2401-2403줄
if pos < current_pos:
    continue
```

- 이미 앵커 선택 시 `anchor >= current_pos` 조건으로 필터링
- 따라서 `pos < current_pos` 체크는 대부분 불필요

**영향:**
- 작은 오버헤드이지만 불필요한 연산

**해결 방안:**
- 로직 재구성하여 불필요한 체크 제거

---

### 5. V2 vs V3 비교

**V2 검증 방식:**
- 첫 번째 앵커만 사용
- 윈도우 크기별로 독립적으로 검증 (각각 1회씩)
- 단순한 루프 구조

**V3 검증 방식:**
- 여러 앵커를 순차적으로 검증
- while 루프로 앵커 전환 처리
- 더 복잡한 로직

**추가 오버헤드:**
- 앵커 탐색 루프
- current_pos 업데이트 및 관리
- 여러 앵커에서 검증 수행

---

## 성능 개선 권장사항

### 우선순위 1: 예측값 생성 최적화
1. 예측값 존재 여부 확인 후 생성
2. 생성 결과 캐싱
3. 사용자에게 수동 생성 옵션 제공

### 우선순위 2: 앵커 탐색 최적화
1. 이진 탐색 사용 (`bisect.bisect_left`)
2. 앵커 인덱스 추적

### 우선순위 3: DB 쿼리 최적화
1. 배치 쿼리 사용
2. DB 연결 재사용

### 우선순위 4: 코드 최적화
1. 불필요한 체크 제거
2. 변수 재사용

---

## 예상 성능 개선 효과

- 예측값 생성 최적화: **50-90% 시간 단축** (가장 큰 효과)
- 앵커 탐색 최적화: **5-10% 시간 단축**
- DB 쿼리 최적화: **10-20% 시간 단축**
- 코드 최적화: **1-5% 시간 단축**

---

## 즉시 적용 가능한 해결책

1. **테스트 앱에서 `auto_generate_predictions=False` 옵션 추가**
2. **예측값 생성 전에 존재 여부 확인 로직 추가**
3. **앵커 탐색에 이진 탐색 적용**
